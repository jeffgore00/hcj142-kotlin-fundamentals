Course URL: https://app.pluralsight.com/library/courses/kotlin-fundamentals

- [1. Course Overview](#1-course-overview)
  - [1.1 Overview](#11-overview)
- [2. Introduction](#2-introduction)
  - [2.1 Course introduction](#21-course-introduction)
  - [2.2 Installing Kotlin](#22-installing-kotlin)
  - [2.3 What is Kotlin](#23-what-is-kotlin)
  - [2.4 Basic Coding in Kotlin](#24-basic-coding-in-kotlin)
- [3. Getting Started with Kotlin](#3-getting-started-with-kotlin)
  - [3.1 Getting started with Kotlin - intro](#31-getting-started-with-kotlin---intro)
  - [3.2 Using Kotlin Without Creating Any Class Definitions](#32-using-kotlin-without-creating-any-class-definitions)
  - [3.3 Kotlin's support for immutability](#33-kotlins-support-for-immutability)
  - [3.4 String Templates in Kotlin](#34-string-templates-in-kotlin)
  - [3.5 Using 'if' as an expression](#35-using-if-as-an-expression)
  - [3.6 How Kotlin Improves the Handling of Null Values](#36-how-kotlin-improves-the-handling-of-null-values)
  - [3.7 The 'When' Statement in Kotlin](#37-the-when-statement-in-kotlin)
  - [3.8 Using 'try'](#38-using-try)
  - [3.9 Kotlin's looping constructs](#39-kotlins-looping-constructs)
  - [3.10 Kotlin's support for exceptions](#310-kotlins-support-for-exceptions)
- [4. Functions In Kotlin](#4-functions-in-kotlin)
  - [4.1 Functions In Kotlin - Introduction](#41-functions-in-kotlin---introduction)
  - [4.2 Declaring functions](#42-declaring-functions)
  - [4-3 Interoperability with Java](#4-3-interoperability-with-java)
  - [4-4 Default Parameters](#4-4-default-parameters)
  - [4-5 Named Parameters](#4-5-named-parameters)
  - [4.6 Extension Functions](#46-extension-functions)
  - [4.7 Infix functions](#47-infix-functions)
  - [4.8 Tail Recursive Functions](#48-tail-recursive-functions)
- [5 Programming with Types](#5-programming-with-types)
  - [5.1 Programming with Types Introduction](#51-programming-with-types-introduction)
  - [5.2 Interfaces](#52-interfaces)
  - [5-3 Defining Classes in Kotlin](#5-3-defining-classes-in-kotlin)
  - [5-4 Sealed classes](#5-4-sealed-classes)
  - [5-5 Providing Constructors](#5-5-providing-constructors)
  - [5-6 Data Classes](#5-6-data-classes)
- [6. Companion Objects](#6-companion-objects)
  - [6-1 Companion Objects Introduction](#6-1-companion-objects-introduction)
  - [6-2 Using the `object` keyword](#6-2-using-the-object-keyword)
  - [6-3 Extending objects](#6-3-extending-objects)
  - [6-4 Companion objects](#6-4-companion-objects)
  - [6-5 Using companion objects](#6-5-using-companion-objects)
- [7 Using High Level Functions](#7-using-high-level-functions)
  - [7-1 Using High Level Functions - Intro](#7-1-using-high-level-functions---intro)
  - [7-2 Using Anonymous Classes to Implement Functionality](#7-2-using-anonymous-classes-to-implement-functionality)
  - [7-3 Introducing Higher Order Functions](#7-3-introducing-higher-order-functions)
  - [7-3 Using Higher Order Functions In Kotlin](#7-3-using-higher-order-functions-in-kotlin)
  - [7-4 Closures](#7-4-closures)
  - [7-5 With and Apply](#7-5-with-and-apply)
- [8. Filtering and Sorting](#8-filtering-and-sorting)
  - [8.1 - Filtering and Sorting Intro](#81---filtering-and-sorting-intro)
  - [8.2 - Filter and Map in Kotlin](#82---filter-and-map-in-kotlin)
  - [8.3 - Introducing Predicates](#83---introducing-predicates)
  - [8.4 - Using Predicates](#84---using-predicates)
  - [8.5 - Using FlatMap in Kotlin](#85---using-flatmap-in-kotlin)
- [9. Working with Infinite Collections](#9-working-with-infinite-collections)
  - [9.1 - Working with Infinite Collections Intro](#91---working-with-infinite-collections-intro)
  - [9.2 Using sequences](#92-using-sequences)
  - [9.3 Terminal operations on sequences](#93-terminal-operations-on-sequences)
- [10. Working with Java Functional Interfaces from Kotlin](#10-working-with-java-functional-interfaces-from-kotlin)
  - [10.1 Intro](#101-intro)
  - [10.2 Passing Kotlin Functions to Java Methods](#102-passing-kotlin-functions-to-java-methods)
  - [10.3 The Use of 'SAM Constructors' from Kotlin](#103-the-use-of-sam-constructors-from-kotlin)
- [11. Using Kotlin's Nullability Constraints to Improve Code](#11-using-kotlins-nullability-constraints-to-improve-code)
  - [11.1 - Intro](#111---intro)
  - [11.2 Null checking in Kotlin](#112-null-checking-in-kotlin)
    - [Safe Call](#safe-call)
    - [Elvis Operator](#elvis-operator)
    - [Safe Cast](#safe-cast)
    - [Not-Null assertions](#not-null-assertions)
  - [11.3 How to use null checking in Kotlin](#113-how-to-use-null-checking-in-kotlin)
  - [11.4 Using the 'let' construct](#114-using-the-let-construct)
  - [11.5 Late initialized properties](#115-late-initialized-properties)
- [12. Understand How Nullability Interacts with Your Existing Java Code](#12-understand-how-nullability-interacts-with-your-existing-java-code)
  - [12.1 Intro](#121-intro)
  - [12.2 Understanding the annotations you can make in Java to make your code null-aware](#122-understanding-the-annotations-you-can-make-in-java-to-make-your-code-null-aware)
  - [12.3 Using annotations in Java code](#123-using-annotations-in-java-code)
  - [12.4 Understanding issues with nullability when overriding Java methods](#124-understanding-issues-with-nullability-when-overriding-java-methods)
- [13. Kotlin Collection Classes](#13-kotlin-collection-classes)
  - [13.1 Kotlin Collection Classes - Intro](#131-kotlin-collection-classes---intro)
  - [13.2 Creating collections in Kotlin](#132-creating-collections-in-kotlin)
  - [13.3 How Java Inter-operates with Kotlin collections](#133-how-java-inter-operates-with-kotlin-collections)
  - [13.4 Using arrays in Kotlin](#134-using-arrays-in-kotlin)
- [14. Using Higher Order Functions](#14-using-higher-order-functions)
  - [14.1 - Using Higher Order Functions - Intro](#141---using-higher-order-functions---intro)
  - [14.2 - Declaring and Using Higher Order Functions](#142---declaring-and-using-higher-order-functions)
  - [14.3 - Inlining functions](#143---inlining-functions)
- [15. Generics](#15-generics)
  - [15.1 Generics - Introduction](#151-generics---introduction)
  - [15.3 Constraints on Generics](#153-constraints-on-generics)
  - [15.4 Reifying Generic type information](#154-reifying-generic-type-information)
  - [15.5 Using Reified Generics](#155-using-reified-generics)
  - [15.6 Modifying Reification with 'noinline'](#156-modifying-reification-with-noinline)
  - [15.7 Generic Variance in Kotlin](#157-generic-variance-in-kotlin)

# 1. Course Overview

## 1.1 Overview

Kotlin is a language used to write applications to be run on the Java Virtual Machine (JVM); it is regarded as a "better Java than Java".

JVM docs: https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-1.html#jvms-1.
>
> The Java Virtual Machine is the cornerstone of the Java platform. It is the component of the technology responsible for its hardware- and operating system-independence, the small size of its compiled code, and its ability to protect users from malicious programs.
>
> The Java Virtual Machine is an abstract computing machine. Like a real computing machine, it has an instruction set and manipulates various memory areas at run time...The Java Virtual Machine knows nothing of the Java programming language, only of a particular binary format, the class file format. A class file contains Java Virtual Machine instructions (or bytecodes)

# 2. Introduction

## 2.1 Course introduction

Evidently, programming is hard in Java because of checking for null values.

There is "way less ceremony" than Java. Fewer lines of code to achieve the same result.

## 2.2 Installing Kotlin

Assuming you've installed it, run `kotlinc` from the command line to open the Kotlin compiler. This opens a Kotlin REPL - a "Read Evaluate Print Loop".

> A read–eval–print loop (REPL), also termed an interactive toplevel or language shell, is a simple interactive computer programming environment that takes single user inputs, executes them, and returns the result to the user; a program written in a REPL environment is executed piecewise

A browser console is a REPL for JavaScript.

`:quit` to quit the Kotline REPL.

Now, outside of that word, Kotlin files have a `.kt` extension. You would generate a `.class` file (similar to compiling Java, since this is for the JVM) by running `kotlinc [kotlinfile].kt`.

Let's compare the Hello World programs in Java vs Kotlin:

```java
/* HelloWorld.java */
public class HelloWorld {
  public static void main(String[] args) {
    System.out.println("Hello world!");
  }
}
```
```kotlin
// HelloWorld.kt
fun main(args: Array<String>) {
  println("Hello, world")
}

// Compiles to a file named "HelloWorldKt.class" (note the Kt in the name)
```
The above Kotlin example compiles to a valid `.class` file. How? We didn't declare a class. The compiler constructs a class on our behalf and marks that function as a static function within the class.

Let's note some other key differences. In the Kotlin example:

- The variable name comes first, THEN the type
- An array is not implied with `Type[]`, instead it is explicit: `Array<Type>`
- There is no class
- There is no return type (because it defaults to a `unit` return type, this is like `void` in Java and how JS implicitly returns `undefined`)
- No semicolon at the end of the `println`

Something to look into. This doesn't work:

```
kotlinc HelloWorld.kt
java HelloWorldKt
```

But per the tutorial you can do this.
```
kotlinc HelloWorld.kt -include-runtime -d HelloWorld.jar
java -jar HelloWorld.jar
```

Here's the answer.

> When you write an application in Java, you get to rely on all of the standard class libraries. The java. classes (e.g. java.lang.*, java.util.* ...) are included with every JRE, so you don't need to package them yourself.
>
> Kotlin includes its own standard class library (the Kotlin runtime), separate to the Java class library. To distribute a jar file that can be run by anyone with a plain old JRE, you need to bundle the Kotlin runtime as well.

## 2.3 What is Kotlin

- It's a JVM language, meaning it compiles to Java bytecode.
- It's object oriented
- It's also functional, supports higher order functions. Functions are first-class citizens.

## 2.4 Basic Coding in Kotlin

`var` is for reassignable variables; `val` is for immutable ones.

```kotlin
// com/rsk/Person.kt
package com.rsk

// note the constuctor is the argument to the class.
// Also note: you use `var` or `val` in constructors, but not regular funcs.
class Person(var name: String) {
    fun displayName() {
        println("The person's name is $name")
    }

    fun callExternalFuncWithName(externalFunc: (name:String) -> Unit) {
        externalFunc(Name);
    }
}

// main.kt
import com.rsk.Person

fun main(args: Array<String>) {
    println("Hello, world");

    val kevin = Person("Kevin");
    val kevinsFavoriteNumber = 3;

    kevin.displayName()

    kevin.callExternalFuncWithName(::makeFunOf)
}

fun makeFunOf(var name: String){
    println("$name IS A DOODIE HEAD")
}
```
In Java you would have had to declare both the class and its method `displayName` as `public`. But in Kotlin that's the default behavior.

Note the demonstration of Kotlin's ability to accept functions as an argument with its function `callExternalFuncWithName`.

Also note that Kotlin supports the `"${variable}"` syntax, but the IDE recommends the more concise `"$variable"` syntax IF the variable is not a property accessor. But if you want to interpolate `obj.value` (a "compound variable"), then you must use `"${obj.value}"`

Note the way you have to reference functions outside of their definition - with `::`. Evidently this is similar to Java.

Note also that we were able to declare variables without declaring their type. It's inferred from what's going on on the right hand side of that assignment.

Note also there's no `new` keyword when utilizing the `Person` constructor.

# 3. Getting Started with Kotlin

## 3.1 Getting started with Kotlin - intro

Again, why it may be better than Java:

- No `new` keyword
- No getters/setters
- No need to anticipate the type of exception that may be thrown


## 3.2 Using Kotlin Without Creating Any Class Definitions

Uses a tool called `fernflower` to decompiled the compiled `MainKt.class` file to see what the compiler does to make the Kotlin source compatible with the JVM. As we said before, if the source does not contain a class it will wrap that in a `class`, and functions would be `static` members of that class.

Here's that output without the Metadata decorator:
```java
import kotlin.Metadata;
import kotlin.jvm.internal.Intrinsics;
import org.jetbrains.annotations.NotNull;

public final class MainKt {
   public static final void main(@NotNull String[] args) {
      Intrinsics.checkParameterIsNotNull(args, "args");
      String var1 = "Hello, world";
      System.out.println(var1);
   }
}
```

If you need, you can go back here to see how he configured IntelliJ to export a .jar file with the Kotlin runtime bundled in the "artifacts" directory.

## 3.3 Kotlin's support for immutability

`var` means variable (reassignable); `val` means value (not reassignable).

In Java, files and classes need to map 1:1, and the class name needs to be the same as the file name.

Not in Kotlin. You can declare a `class` in the same file as a stand-alone `fun`.

Kotlin supports variable assignment types, but doesn't require them:

```kotlin
// either of these work:
var firstQ = Question()
var secondQ:Question = Question()
```

He mentions a "JavaBean". What's that?

https://stackoverflow.com/questions/3295496/what-is-a-javabean-exactly
> A JavaBean is just a standard:
>
> - All properties private (use getters/setters)
> - A public no-argument constructor
> - Implements Serializable.

So when you do create a class, it makes it sort of like a JavaBean, except without that serializable part:

```kotlin
class Person(var name: String) {}
```
...compiles to:
```java
import kotlin.Metadata;
import kotlin.jvm.internal.Intrinsics;
import org.jetbrains.annotations.NotNull;

public final class Person {
   @NotNull
   private String name;

   @NotNull
   public final String getName() {
      return this.name;
   }

   public final void setName(@NotNull String var1) {
      Intrinsics.checkParameterIsNotNull(var1, "<set-?>");
      this.name = var1;
   }

   public Person(@NotNull String name) {
      Intrinsics.checkParameterIsNotNull(name, "name");
      super();
      this.name = name;
   }
}
```
Note the most important thing here - when you declare a variable within a Kotlin class, or in the constructor, the compiler will convert it to a private variable with a public-facing getter and setter.

## 3.4 String Templates in Kotlin

(covered earlier)

## 3.5 Using 'if' as an expression

This code works:
```kotlin
if (q.answer == q.correct) {
  println("You're right")
} else {
  println("You're wrong")
}
```
In Java, this wouldn't work because `==` is strictly for reference equality, and those are two different properties being compared. You would have to use `q.answer.equals(q.correct)`

When variables are declared they have to be initialized. The only exception is if the variable is an `abstract` one, but too early to know how to use that yet.

In Kotlin `if` is an *expression*. So you can do this:

```kotlin
val message = if (q.answer == q.correct) {
  "You're right"
} else {
  "You're wrong"
}
```

## 3.6 How Kotlin Improves the Handling of Null Values

In Kotlin, we have to explicitly tell the compiler that something can take on a null value, rather than anything being nullable and always guarding against it.

We do this with the `?` appended to the type to signify that the value can be null.

```kotlin
class Person(var name: String) {
  var veteranStatus: String? = null
  var firstChild:Person? = null

  // The below will throw an error because `firstChild` is not guaranteed to be non-null! Thanks Kotlin!
  val firstChildName = firstChild.name

  // The proper way to do it. If `firstChild` does not exist, the returned value is `null`.
  val firstChildName = firstChild?.name
}
```

## 3.7 The 'When' Statement in Kotlin

There is no `switch` statement in Kotlin. But there is `when`:

```kotlin
fun choose(flavor : String?) {
  when (flavor) {
    "lemon" -> println("Nice, sour is good")
    "pig kidney" -> println("Gross, man!")
    null -> println("You gotta pick something")
    else -> println("Never heard of that, but you do you")
  }
}
```
Note the function parameter `flavor` with the `String?` type. This does not mean the parameter is optional! It only means that it is allowed to be `null`. So `null` would have to be explicitly passed into this function.

## 3.8 Using 'try'

Just like `if`, `try` is an expression in Kotlin.

```kotlin
val age: Int? = try {
  Integer.parseInt(person.age)
} catch (e: NumberFormatException) {
  null
}
```

## 3.9 Kotlin's looping constructs

`while` and `do...while` are the same as Java, as the same as JS.

But `for` loops are different than Java/JS.

First, lets look at the way a *range* is defined in Kotlin:

```kotlin
var numsFromOneToTen = 1..10
```
As you can see the default incrementor is 1. This is inclusive of 1 and 10.

In Kotlin, using this range in a `for` loop:

```kotlin
for (i in 1..10) {
  // i = 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
}
```

We can also use `step` to define the interval of incrementation:
```kotlin
for (i in 1..10 step 2) {
  // i = 1, 3, 5, 7, 9
}
```

We can also use `downTo` to indicate we should start from the end and go down to a certain point.
```kotlin
for (i in 10 downTo 5 step 2) {
  // i = 10, 8, 6
}
```
Note you can't just do `10..5`, you think you'd be able to go in the opposite direction, but you can't.

But what if you want your classic Java/JS "half-closed" range, inclusive of the beginning, exclusive of the end? Well you can use `until`:

```kotlin
for (i in 1 until 5) {
  // i = 1, 2, 3, 4
}
```
(Not sure if using `until` in reverse is possible.)

You can create a more explicit list using `listOf`, rather than using a range:

```kotlin
var retiredJerseyNumbers = listOf(2, 23, 30, 44)

for (number in retiredJerseyNumbers) {
  // stuff
}
```

...and you can even extend this loop to provide you the index:
```kotlin
var retiredJerseyNumbers = listOf(2, 23, 30, 44)

for ((index, number) in retiredJerseyNumbers.withIndex()) {
  // stuff
}
```
The course sort of pulls this out of nowhere, the first indication of a map(!), in order to show you that you can use a `for` loop on a map. But the `TreeMap` he provides doesn't actually work, seems like it's from a Java library. Did some research and found this:
https://www.deadcoderising.com/how-to-create-maps-in-kotlin-using-5-different-factory-functions-2/

```kotlin
var ages = mutableMapOf("Jeff" to 34, "Dana" to 29)
ages["Jeff"] = 35
ages["Dana"] = 30

for((name, age) in ages) {
  println("$name is $age years old")
}
```

Back to ranges real quick, i.e. `..`. You can implement a range over characters too, i.e. `a..z`.

"In fact, you can have a range over anything that implements the `Comparable` interface."

## 3.10 Kotlin's support for exceptions

Kotlin uses *unchecked exceptions* (I think this means uncaught exceptions, like JavaScript). So we don't have to specify if any class throws an exception.

Like JS and JavaScript, it supports a `finally` after the end of try/catch.

(Look more into how Kotlin can use Java libraries. For instance `FileReader`.)

# 4. Functions In Kotlin

## 4.1 Functions In Kotlin - Introduction

In Kotlin, functions don't need to be declared as part of class. In Java, no functions can exist outside of a class definition. Static functions still belong to a class.

In Kotlin, functions can have default parameters (not possible in Java).

And you can have named parameters - not even possible with JS (closest would be passing object as prop).


## 4.2 Declaring functions

The function signature must have an input type and a return type, if applicable. But if there are no parameters or no return, then we don't have to supply the type (instead of Java, where you'd have to say `void`).

Here's our first ever example with a return value:

```kotlin
fun display(message: String) : Boolean {
    println(message)
    return true
}
```

Just like Java, functions can be kept in `package`s. (Java has a default package, look into this). The package directive must match the file location.

```kotlin
package utils
// "utils" should be a folder that is a sibling to the `MainKt.class` that is executed by the JVM

// function/class declarations here.
```

Kotlin also supports function expressions, similar to JS:
```kotlin
// remember `if` is an expression in Kotlin
fun max(a: Int, b: Int): Int = if (a > b) a else b
```

## 4-3 Interoperability with Java

Let's say we compiled this `utils` package mentioned above, which had a filename called `Display.kt`, which in turn had a stand-alone function (no class) called `display`.

And then let's say we were writing a Java program that wanted to utilize this Kotlin code. We should know that the Kotlin compiler will transform this:

```kotlin
/* utils/display.kt */
package utils

fun display(str: String) : Boolean {
  println(str)
  return true
}
```
...into this:

```java
package utils;

class DisplayKt {
  static boolean display(String str) {
    // etc
  }
}
```

OK, so let's get into some Java code that would use our Kotlin package.

```java
import rsk.*;

public class App {
  public static void main(String[] args) {
    DisplayKt.display("Hello, world from Java")
  }
}
```

What if we don't want our Kotlin export to be called `DisplayKt`? Well we can use a special annotation in our Kotlin files to name the generated class:

```kotlin
/* utils/display.kt */
@file:JvmName("DisplayUtils")

package utils

fun display(str: String) : Boolean {
  println(str)
  return true
}
```

## 4-4 Default Parameters

Example of a function with default parameters:

```kotlin
fun connect(addr: URI, useProxy: Boolean = true) : Boolean {

}
```

But because Java doesn't have default parameters, how can we compile compatible code? Let's use the `@JvmOverloads` annotation. This will make the Kotlin compiler generate overloads for the function.

In this example, this annotation will result in two Java functions - one that takes one argument, and one that takes two. And remember this annotation is like a decorator, so it applies only to the function directly underneath it.

```kotlin
@JvmOverloads
fun connect(addr: URI, useProxy: Boolean = true) : Boolean {

}
```

## 4-5 Named Parameters

Remember this function?

```kotlin
@JvmOverloads
fun connect(addr: URI, useProxy: Boolean = true) : Boolean {

}
```

Here's how you can call it with one parameter actually named. This makes the code meaning clearer:

```kotlin
connect(URI(/* some URL */), useProxy = false)
```

Note this is only possible for this configuration. If you tried to do the opposite:

```kotlin
// ERROR! "Mixing named and positioned arguments is not allowed"
connect(addr = URI(/* some URL */), false)
```
You would get an error. The logic is: "once we use a named parameter in an argument, we must use named parameters for all subsequent arguments."

But what's cool about named parameters is that if you name ALL of your parameters, then you can pass them in any order you please.

Java doesn't support named parameters. Neither does JS.


## 4.6 Extension Functions

These are not in Java, they're in C# though.

With this, you can "add" functions to classes you don't own. This cuts down on utility classes and makes code easier to read.

Think about how you can alter a JS prototype to have new methods. In this example we extend the `String` class with a new method:

```kotlin
fun main(args: Array<String>) {
    val text = "With     lots  \t  of whitespace"
    printLn(text.myCustomSpaceConsolidator())
}

fun String.myCustomSpaceConsolidator() : String {
  var regex = Regex("\\s+")
  return regex.replace(this, " ")
}
```

## 4.7 Infix functions

Infix functions are:

- member or extension functions
- have a single parameter
- marked with the `infix` keyword

..and they allow you to call the function only with the name, without the dot or the parentheses. The method would belong to the object on the left hand side, and would take the expression on the right hand side as its sole argument.

Here's an example:

```kotlin
class State(var desc: String) {}

infix fun State.mergedWith(otherState: State) : State {
    return State("${this.desc}; ${otherState.desc}")
}

fun main(args: Array<String>) {
    val clientState = State("browser: chrome")
    val serverState = State("featureService: on")

    // Here it is!
    val mergedState = clientState mergedWith serverState
    println(mergedState.desc)
}

```
Doesn't `mergedWith` in the above example look almost like a custom operator? Well, it sort of is. And you can leverage a C++ feature here and go further and actually overload an operator. Let's say you wanted the `+` operator to actually execute the task of `mergedWith`. But you'd actually have rename `mergedWith` to `plus` which is what the operator is named.

You could do this with the `operator` keyword:

```kotlin
class State(var desc: String) {}

// Note "operator"
infix operator fun State.plus(otherState: State) : State {
    return State("${this.desc}; ${otherState.desc}")
}

fun main(args: Array<String>) {
    val clientState = State("browser: chrome")
    val serverState = State("featureService: on")

    // Note its use here:
    val mergedState = clientState + serverState
    println(mergedState.desc)

    // and this still works because the prior implementation is an overload, not replacing the function entirely.
    println(2 + 2)
}
```
Unlike C++, Kotlin limits which operators you can overload.

Why would you want to do this? For one, this makes Domain Specific Languages (DSLs) easier to write.


## 4.8 Tail Recursive Functions

Kotlin supports tail recursion. You would have to mark this as `tailrec`, and as long is it follows the right form and is truly tail recursive, the Kotlin will optimize this by turning it into a loop inside the bytecode.

Fibonacci in Kotlin with tail recursion:

```kotlin
// Calculates the nth fibonacci number
tailrec fun fib(n: Int, a: BigInteger, b: BigInteger): BigInteger {
  return if (n == 0) b else fib(n - 1, a + b, a)
}
```
# 5 Programming with Types

## 5.1 Programming with Types Introduction
(nothing)

## 5.2 Interfaces

Here you go:

```kotlin
interface Time {
    fun setTime(hours: Int, mins: Int = 0, secs: Int = 0)
}

class AlienTime : Time {
    override fun setTime(hours: Int, mins: Int, secs: Int) {}
    fun setNextMoltingHour(hour: Int) {}
}
```
Note Kotlin has no `implements` or `extends` keyword, the colon `:` suffices in the class defintion.

And also IMO the `override` is a little confusing, but you need to use that keyword. It's not really an override in terms of changing the implementation, it's satisfying ther requirements of the interface and *following* the implementation. Without `override` you get this error: "'setTime' hides member of supertype 'Time' and needs 'override' modifier."

The only time you wouldn't need to do this is if the interface had a default implementation:

```kotlin
interface Time {
    fun printSomethingSimple() {
        println("now")
    }
}

class AlienTime : Time {
  // this has access to the `printSomethingSimple` method
}
```

What if you have a class that implements multiple interfaces? Separate them with a comma, i.e. `class Sample : A, B`

And what if each of those interfaces has a method of the same name with a default implementation? In which case, you must `override`, even if you want to call a default implementation, which you would do via `super`:

```kotlin
interface A { fun doSomething() = {} }
interface B { fun doSomething() = {} }

class Sample : A, B {
  override fun doSomething() = {
    super<A>.doSomething()
  }
}
```

## 5-3 Defining Classes in Kotlin

In Kotlin, classes are `public` by default. And they're `final` by default, meaning they can't be used for inheritance (in Java, they're `open` by default, the opposite, but a best practice in Java is to always use `final`).

Methods are `final` by default as well, meaning they can't be overridden. To counteract that, we use the `open` keyword, which allows either a class to be implemented or a method to be overridden.

```kotlin
open class Person {
    var firstName: String = ""
    var lastName: String = ""
    fun getName() : String = "$firstName $lastName"
}

class Student : Person() {
    override fun getName() : String { return "student. my name doesnt matter" }
}
```
Note that because we're extending a class rather than an interface, the parent class is invoked like a function.

Kotlin supports `abstract` classes as well. What makes them different from  interfaces is that they can store state. And like an interface, if a method is defined, it must be used.

```kotlin
abstract class Person {
    var firstName: String = ""
    var lastName: String = ""
    open fun getName() : String = "$firstName $lastName"
    abstract fun getAddress() : String
}

class Student : Person() {
    // overriding because I want a custom implemention, otherwise I don't have to do this. The parent function is not abstract, has an implementation.
    override fun getName() : String { return "student. my name doesnt matter" }

    // overriding because I MUST provide an implementation for the abstract function, unless I wanted this function to be abstract as well
    override fun getAddress() : String { return "my moms house"}
}
```
Kotlin does not use packages for visibility scoping; there's a class identifier called `package-private` in Java but Kotlin doesn't use that. It does have something called `internal`, though - limiting visibilty of a class to only a "module" - look into that. And it still has `private` and `protected`.


## 5-4 Sealed classes

Like "enums on steroids", sealed classes are used to restrict class hierarchies. Classes are defined within the sealed class, meaning the sealed class only allows its innards to inherit it.

```kotlin
sealed class HumanAction {
  class Awaken : HumanAction()
  class FallAsleep : HumanAction()
  class Eat(val food: String) : HumanAction()
}

fun handleHumanAction(action: HumanAction) {
  when (action) {
    is HumanAction.Awaken -> println("Awake")
    is HumanAction.FallAsleep -> println("Asleep")
    is HumanAction.Eat -> println(action.food)
  }
}
```

## 5-5 Providing Constructors

In Java, the constructor would be a function within the class where the name is the same as the class name. (I think.)

In Kotlin, the constructor is just like a function argument, except with the additional `val` or `var` qualifier, which equates to a read-only vs. mutable property, sensibly.

```kotlin
class Person(var name: String) {}
```

If you wanted, though, you could omit the `var`/`val` from the arguments parentheses provided you provide it later with an `init` call:

```kotlin
class Person(name: String) {
  var name: String
  init {
    this.name = name
  }
}
```
Or if you name your variables with an underscore, you can similarly defer the `val` vs `var` designation, but why would you?:

```kotlin
class Person(_name: String) {
  var name = _name
}
```

You can also define secondary constructors within the class.

```kotlin
class Person(var name: String) {
    var age : Int? = null
    constructor(name: String, age: Int) : this(name) {
        this.age = age
    }
}
```
Note the `this(name)` in there: "If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor."

But we may as well use default values instead:

```kotlin
class Person(var name: String, var age: Int? = null) {}
```

Here's how you would pass constructor arguments up to a parent class:

```kotlin
class Student(firstName: String, lastName: String) : Person(firstName, lastName) {}

// or
class Student: Person {
    constructor(name: String) : super(name)
}
```
Note there is no `var` or `val` in the child class's constructor, because those arguments already exist in the parent constructor.

Again, no `new` keyword used in Kotlin to invoke the constructor.


## 5-6 Data Classes

"We frequently create classes whose main purpose is to hold data. In such a class some standard functionality and utility functions are often mechanically derivable from the data."

Kotlin's data classes are like standard classes, but they also come in with built in overrides:
  - `equals` (which is what the `==` operator calls under the hood): deep object equality rather than comparing by reference
  - `toString`: string representation of all the object's key/value pairs, rather than printing the object's address in memory
  - `copy`: not an override, but allows an object to be cloned, with the only changed attributes being the arguments passed in.

Keep in mind that to be visible to all these functions, a property must be in the primary constructor. If it is defined within the class but not in the constructor, it will not be accessible.

```kotlin
data class Product(val style: Int, val color: Int, val size: Int) {
  var vendor = "doesnt matter, wont be in the string"
}

fun main(args: Array<String>) {
    var whiteShirt = Product(1, 1, 2)
    println(whiteShirt.toString()) // Product(style=1, color=1, size=2)

    var blackShirt = whiteShirt.copy(color = 4)
    println(blackShirt.toString()) // Product(style=1, color=4, size=2)

    var blackShirtCopy = blackShirt.copy()
    println(blackShirt == blackShirtCopy) // true
}
```
# 6. Companion Objects

## 6-1 Companion Objects Introduction

## 6-2 Using the `object` keyword

Kotlin itself does not use the `static` keyword. But we can have singletons. The `object` keyword does this - defines a class and creates an instance of that class in one go, creating a singleton.

```kotlin
object DataStoreManager {
  var mongoConnection : MongoConnection? = null;
  var redisConnection : RedisConnection? = null;

  fun connect() {
    // some logic
  }
}
```
Note that there is no constructor because the construction occurs in this definition, and nothing else would have the power to construct it.


## 6-3 Extending objects

It is possible for an `object` to implement an existing class or interface.

```kotlin
object DataStoreManager : LoansDataStore {
  fun connect() {
    // some logic
  }
}
```

And they can be declared inside of other classes:

```kotlin
class LoansDataStore {
  object mongoConnection : MongoConnection
  object redisConnection : RedisConnection

  fun connect() {
    // some logic
  }
}
```

## 6-4 Companion objects

Kotlin classes do not have `static` members. So how do you go about adding static methods to a Kotlin class?

Enter the `companion object`. What makes them companions is that they are used within classes and attached to their enclosing class as a property.

## 6-5 Using companion objects

Here's how you'd create the equivalent of a static method. Let's say you missed JS and you wanted to create a `Math.floor` function.

```kotlin
class Math() {
    companion object {
        fun floor(number : Double) : Double {
            // I would have said kotlin.math.floor(), but the syntax highlighting here has a problem with it, even though its valid.
            return nativeFloor(number)
        }
    }
}
```

So, you see how that is essentially a static method - there is only one instance of this function on the class.

But to make this regarded as a static method by Java, you would have to add the `@JvmStatic` annotation:

```kotlin
class Math() {
    companion object {
        @JvmStatic
        fun floor(number : Double) : Double {
          // implementation
        }
    }
}
```
Look also into how companion objects help with factories.

# 7 Using High Level Functions

## 7-1 Using High Level Functions - Intro

The "strategy pattern" is a gang of four pattern that allows an algorithm's behavior to be selected at runtime.


## 7-2 Using Anonymous Classes to Implement Functionality

You can pass inline / anonymous objects to functions - sort of. They still need to have a type. See this below example.

Keep in mind this is "the OO method", which is evidently the way things are done in Java as well. This is just the setup for a later module that shows that a callback is better.

```kotlin
interface OnComplete {
    fun execute(responseData: String)
}

class ApiFetcher {
    fun fetch(url: String, onComplete: OnComplete) {
        var responseData : String = "initial value";
        // responseData = do some HTTP call
        onComplete.execute(responseData)
    }
}

// Here, an anonymous instance of the `OnComplete` interface is passed to the `fetch` method via the `object` keyword.
fun main(args: Array<String>) {
    var fetcher = ApiFetcher()
    fetcher.fetch("http://coolguy.com/api/guys", object : OnComplete{
        override fun execute(responseData: String) {
            println(responseData)
        }
    })
}
```

## 7-3 Introducing Higher Order Functions

Let's reimplement that with a callback.

```kotlin
class ApiFetcher {
    fun fetch(url: String, callback: (String) -> Unit) {
        var responseData : String = "initial value";
        // data = do some HTTP call
        callback(responseData)
    }
}

fun main(args: Array<String>) {
    var fetcher = ApiFetcher()

    // Below is our lambda function passed in as our callback. Note that it's outside of the parentheses. That's the IDE stylistic preference, though you *could* pass it within the parens like you would a JS function.
    fetcher.fetch("http://coolguy.com/api/guys") { responseData -> println(responseData) }
}
```

## 7-3 Using Higher Order Functions In Kotlin

But wait, it can get even more concise. If the lambda takes just one parameter, then you can use the keyword `it` to refer to the sole parameter. Or you could just use the function reference syntax `::`.

```kotlin
// so instead of
fetch("http://coolguy.com/api/guys") { responseData -> println(responseData) }

// you can do:
fetch("http://coolguy.com/api/guys") { println(it) }

// and you can even go further
fetch("http://coolguy.com/api/guys", ::println)
```

## 7-4 Closures

Kotlin lambdas can mutate state, unlike Java 8+ lambdas. (check this)

## 7-5 With and Apply

Let's take a look at a simple example of a program that creates a meeting:

```kotlin
class Meeting {
    var title: String = ""
    var date: Date = Date()
    var attendees = mutableListOf<String>()

    fun sendInvites() {}
}

fun main(args: Array<String>) {
    var meeting = Meeting()
    meeting.title = "A New World Order"
    meeting.date = Date(2020,12,30)
    meeting.attendees.add("Jeff")
    println("Meeting created")
}
```
This works fine. But using the `with` function (part of the Kotlin standard library, you can do this:

```kotlin
fun main(args: Array<String>) {
    var meeting =  Meeting()
    with(meeting) {
        title = "A New World Order"
        date = Date(2020,12,30)
        attendees.add("Jeff")
    }
    println("Meeting created")
}
```
What's cool about `with` is that the area in brackets is actually a lambda function, receiving the `Meeting` instance as its `this` value. So when it makes those assignments, it is actually assigning those properties on the `meeting`.

What if you want to return that `meeting`? Then you could use `apply`, which has similar syntax, but is called on the object itself, and returns the object itself.

```kotlin
fun main(args: Array<String>) {
    var meeting =  Meeting()
    meeting.apply {
        title = "A New World Order"
        date = Date(2020,12,30)
        attendees.add("Jeff")
    }.sendInvites()
}
```
Extra points for refactoring here:

```kotlin
fun main(args: Array<String>) {
    Meeting().apply {
        title = "A New World Order"
        date = Date(2020,12,30)
        attendees.add("Jeff")
    }.sendInvites()
}
```
# 8. Filtering and Sorting

## 8.1 - Filtering and Sorting Intro

## 8.2 - Filter and Map in Kotlin

An example of `filter`, which is avaiable on Kotlin collections. Note the lambda.

```kotlin
  val ints = listOf(1,2,3,4,5)
  val smallInts = ints.filter{ it < 4 }
```

Works on maps too, since a map is a collection. Note that if you want to define the lambda separately, this typeless destructuring won't work because it won't be able to infer the types. And destructuring may need some extra work.

```kotlin
    val people = mutableMapOf("Jeff" to 34, "Dana" to 29)
    val olderThan30 = people.filter{ (key, value) -> key == "Jeff" }
```

And here's `map`:

```kotlin
  val ints = listOf(1,2,3,4,5)
  val intsSquared = ints.map{ it * it }
```

And they can be chained:

```kotlin
  val ints = listOf(1,2,3,4,5)
  val intsSquared = ints.map{ it * it }.filter{ it < 15 }
```

> Sidenote: there's a `startsWith` method on the `String` class.

Note that with `map` we can return a new type:

```kotlin
  val people = listOf(Person("Jeff"), Person("Dana"))
  val names = people.map{ it -> it.name }
```

## 8.3 - Introducing Predicates

Predicates are lambdas that return Booleans. These are provided on collection classes: `any`, `all`, `count`, `find`


## 8.4 - Using Predicates

Here's `all` and `any`, which reduces a collection to a boolean. `count` returns the number of items that match a predicate (just like `filter` but returning only the length of the resulting collection).

```kotlin
fun main(args: Array<String>) {
    val pagesRendered = listOf(true, true, false, true)
    // note not "it == true", like JS it can be simplified
    val allPagesRendered = pagesRendered.all{ it }
    val anyPagesRendered = pagesRendered.any{ it }
    val countPagesRendered = pagesRendered.count{ it }
    println(allPagesRendered) // false
    println(anyPagesRendered) // true
    println(countPagesRendered) // 3
}
```

We can assign predicates to variables, though if we do that we can't supply the lambda externally in curly brackets.

```kotlin
fun main(args: Array<String>) {
    val applicationDecisions = listOf("D", "P", "P", "A")
    val isPending = { decision: String -> decision == "P"}

    // Note that we're passing this predicate as a normal argument, can't use the curly brace syntax here:
    var pendingDecisions = applicationDecisions.filter(isPending)
    println(pendingDecisions.toString())
}
```

`find` returns the first element that matches the predicate:

```kotlin
fun main(args: Array<String>) {
    val people = listOf(
        mutableMapOf("first" to "Jeff", "last" to "Gore"),
        mutableMapOf("first" to "Jeff", "last" to "Sessions")
    )
    // i.e. [{ first: "Jeff", last: "Gore" }, { first: "Jeff", last: "Sessions" }]

    // will return null if nothing found
    var firstPersonNamedJeff = people.find { person -> person["first"] == "Jeff" }
    println(firstPersonNamedJeff.toString()) // {first=Jeff, last=Gore}
}
```

Side notes: The above did NOT work when used dot notation like so:

```kotlin
// Error: Function invocation 'first(...)' expected
{ person -> person.first == "Jeff" }
```
It might be because the maps in the above example are not of a specific type and declared inline. Because if `Person` were a type, this would work.


## 8.5 - Using FlatMap in Kotlin

Some cool stuff you can do:

```kotlin
val meetings = listOf(Meeting("lunch"), Meeting("dinner"))

// This works:
val titles = meetings.map{ it.title }

// So does this:
val titles = meetings.map(Meeting::title)
```

There is also a `flatten` and `flatMap` method to flatten collections and map over nested collections to return a flattened one, respectively.

There's also a `distinct` method to filter out duplicates, but remember, if your collection members are objects, then they need to be a member of a `data` class.


# 9. Working with Infinite Collections

## 9.1 - Working with Infinite Collections Intro

`filter` and `map` aren't good if your lists are huge, because they "eagerly" create auxillary data structures.

Enter *sequences*. They are evaluated lazily, i.e. only when we ask it to.

## 9.2 Using sequences

Let's look at the difference betwen this:

```kotlin
val numbers = listOf(1, 2)

val output = numbers.filter{
    println("Filtering $it")
    it < 10
}.map{
    println("Mapping $it to ${it * 10}")
    it * 10
}

/*
Output:
Filtering 1
Filtering 2
Mapping 1 to 10
Mapping 2 to 20
*/
```

...and this:


Let's look at the difference betwen this:

```kotlin
val numbers = listOf(1, 2)

val output = numbers.asSequence().filter{
    println("Filtering $it")
    it < 10
}.map{
    println("Mapping $it to ${it * 10}")
    it * 10
}

/*
Output:
(none)
*/
```
What is going on here? "When the processing of an Iterable includes multiple steps, they are executed eagerly: each processing step completes and returns its result – an intermediate collection."

But a sequence is different. As soon as we declare `.asSequence()`, then the `filter` and `map` methods are now operating on and returning a `Sequence`, not an `Iterable`. And that means that although the sequence is ready to do work, it won't actually compute the value until you ask it to, in a "terminal operation."

A `Sequence` value can only be retrieved with a "terminal operation". "If a sequence operation returns another sequence, which is produced lazily, it's called intermediate. Otherwise, the operation is terminal. Examples of terminal operations are toList() or sum()."

So, in the above example, let's add a terminal operation:

```kotlin
fun main(args: Array<String>) {
    val numbers = listOf(1, 2)

    val output = numbers.asSequence().filter{
        println("Filtering $it")
        it < 10
    }.map{
        println("Mapping $it to ${it * 10}")
        it * 10
    }

    println(output.toList().toString())
}

/*
Output:
Filtering 1
Mapping 1 to 10
Filtering 2
Mapping 2 to 20
[10, 20]
*/
```
Also note another key difference - "`Sequence` performs all the processing steps one-by-one for every single element. In turn, `Iterable` completes each step for the whole collection and then proceeds to the next step."

## 9.3 Terminal operations on sequences

So an obviously good choice for a Sequence is if you want to execute a `find` on an array but have to `map` it first. If you do it normally, you would have to transform the entire array via `map` before getting to `find`, which is a terminal operation.

This is apparently identical to the Java 8+ `Stream`, but Kotlin created a new class for this so that it can be available everywhere; evidently the Java streams are not available on Android.

# 10. Working with Java Functional Interfaces from Kotlin

## 10.1 Intro

In Java, "events" are usually methods that accept something of type Interface, where you call methods on the passed-in Interface.

A *functional interface* i.e. SAM (single abstract method) interface can accept a lambda in Java 8+.


## 10.2 Passing Kotlin Functions to Java Methods

Didn't really understand this, but the idea is that you can import a Java class with a method with a SAM interface and in Kotlin you can call it with a lambda.

Here's a webpage with an example:
```java
public interface Adder {
    public void add(int a, int b);
}
```

```kotlin
val adder = Adder { a, b -> a + b }
```
This works because `Adder` only has one abstract method - that is, only one method without an implementation. (It also just has one method total, but that's beside the point).

Therefore when Kotlin or Java (this works in Java 8+, btw) passes a lambda to the constructor, it's undeniable what that lambda is for - supplying the implementation for that abstract method.

## 10.3 The Use of 'SAM Constructors' from Kotlin

What happens when the compiler cannot explicitly convert a lambda to a [Java] functional interface?

You would have to simply use the SAM interface as a constructor, then pass that to whatever is requiring it.

# 11. Using Kotlin's Nullability Constraints to Improve Code

## 11.1 - Intro

Here's an example of a Java function that shows the problem with Java and nulls:

```java
boolean closeMeeting(Meeting meeting) {
  if (meeting.canClose) return meeting.close();
  return false;
}
```
If meeting is `null`, you get a `NullPointerException`. But in Kotlin, the same function (as far as syntax) is safe, and will not even compile if you tried to pass null into it.

```kotlin
// This is functionally different, doesn't accept nulls. But is the most strict/faithful conversion of the Java
fun closeMeeting(meeting: Meeting) : Boolean {
  return if (meeting.canClose) meeting.close() else false
}
```

We've already covered how `?` in Kotlin means nullable, not optional. So let's say an object is nullable. If you want to call a method on that object, you must tack on `?` to the nullable object.

```kotlin
val meeting: Meeting? = null
meeting?.close()
```

Interesting example:
```kotlin
val nullableMeeting : Meeting? = null
var nonNullMeeting : Meeting = Meeting()

// This would fail because `Meeting` and `Meeting?` are not the same types.
nonNullMeeting = nullableMeeting
```

## 11.2 Null checking in Kotlin

### Safe Call

```kotlin
// If m is null, method is not called.
m?.method()
```
### Elvis Operator

OK, something new - the Elvis operator. `?:` aka the null-coalescing operator. This is similar to the logical OR in JS `||`:

```kotlin
// If existing meeting is not null, use that, otherwise create a new meeting.
val newMeeting = existingMeeting ?: Meeting()
```

### Safe Cast

"To avoid an exception being thrown, one can use a safe cast operator `as?` that returns null on failure":

```kotlin
// If `y` is not a String, `x` will be assigned to null. Note that `x` must be nullable for this to work.
val x: String? = y as? String
```

### Not-Null assertions

```kotlin
// This will assert that `meeting` is not null and throw an error from that line if it is.
meeting!!.sendInvites()
```

## 11.3 How to use null checking in Kotlin

Here's how we'd write functionally equivalent code to that earlier Java example that accepted nulls.

```kotlin
fun closeMeeting(meeting: Meeting?) : Boolean {
  return if (meeting?.canClose === true) meeting?.close() else false
}
```

Remember there's no "truthiness" here. `meeting?.canClose` can return *three* different values: `true`, `false`, or `null`. So we have to explicitly check for `true` in the `if ` statement.


## 11.4 Using the 'let' construct

Let's say you are using a function provided by some external code that you don't own that does not accept null values, but you want to conditionally call it only if a value is not null.

Enter the `let` function, part of the Kotlin standard library. This is available on the "prototype" of all instances and passes the instance itself as the sole argument:

```kotlin
// Either of these work, because it accepts a single parameter.
    nullableMeeting?.let(::passMeetingToExternalService)
    nullableMeeting?.let{ passMeetingToExternalService(it)}
```


## 11.5 Late initialized properties

Don't be tempted to make a variable nullable just because you don't want to give a value yet. We can use `lateinit` to tell the Kotlin compiler that we promise to initalize the variable later.

```kotlin
lateinit var address: Address
```

This is useful in testing, per the documentation:

```kotlin
public class MyTest {
    lateinit var subject: TestSubject

    @SetUp fun setup() {
        subject = TestSubject()
    }

    @Test fun test() {
        subject.method()  // dereference directly
    }
}
```

# 12. Understand How Nullability Interacts with Your Existing Java Code

## 12.1 Intro

Kotlin understands annotations from the Java world in these packages: `javax.annotation`, `android.support.annotation`, `org.jetbrains.annotation`. Among these annotations is `@Nullable` and `@NotNull` from jetbrains.


## 12.2 Understanding the annotations you can make in Java to make your code null-aware

Here's Java doing Kotlin a favor:

```java
public @Nullable String meetingTitle() {
  return title;
}
```
That would let the Kotlin compiler know that the return value of this function is `String?`.

Another favor from java:
```java
public String addTitle(@NotNull String title) {
  this.title = title;
  return title;
}
```

## 12.3 Using annotations in Java code

But what if there are annotations in the Java code that your Kotlin code is using? In that case you have to handle the null checks in Kotlin yourself.

Let's say you see this error message: "Type mismatch: inferred type is String! but Int was expected."

Note the exclamation point: "String!". That means String is a "platform type", i.e. coming from a platform that's not Kotlin. "Any reference in Java may be null, which makes Kotlin's requirements of strict null-safety impractical for objects coming from Java. Types of Java declarations are treated specially in Kotlin and called platform types."

"String!" essentially means "String? or String"

You can't define these yourself; it's just for your knowledge when you get an error message from the compiler.


## 12.4 Understanding issues with nullability when overriding Java methods

Just shows that when implementing a Java interface you can choose to make your Kotlin implementation pick up the Slack where Java failed in terms of nullability:

```java
public interface Address {
  // Note the return type of String in Java means "String or null"
  public String getFirstAddress()
}

```kotlin
class HomeAddress : Address {
  // now this method is locked into always returning a String
  override fun getFirstAddress(): String {
    return ""
  }
}
```

# 13. Kotlin Collection Classes

## 13.1 Kotlin Collection Classes - Intro

- Collections themselves can be nullable
- Collections can hold null values
- Collections can be read-only or mutable


## 13.2 Creating collections in Kotlin

- `listOf`, `setOf`, `mapOf`
- `arrayListOf`, `hashSetOf`, `hashMapOf`
- `mutableListOf`

Let's define a list of people.

```kotlin
// An explicitly typed list
val people: listOf<Person?>(Person("Jeff"), null)

// An implicitly typed list, will have the same type as above
val people: listOf(Person("Jeff"), null)

val nullableListOfNullablePeople = List<Person?>? = null
```

`add` is like `push` for lists.

But `listOf`, by default, returns a read-only list. Just like all the other methods we mentioned. So you want `mutableListOf` for that, with the matching `MutableList` type. In other words, the collections are immutable unless you use the `mutable` types.

And when we say immutable, we mean it. No adding to lists, no adding or removing key-value pairs. This is not the same thing as `val` vs `var`.

OK, so let's say we're dealing with a `List<Person?>` and we want to iterate through it.

```kotlin
// This works, but prints `null` if the person is null
for (person: Person? in people) {
  println(person?.age)
}

// This is better
```kotlin
for (person: Person in people.filterNotNull()) {
  println(person?.age)
}
```
Note the built in Kotlin collection method `filterNotNull`.


## 13.3 How Java Inter-operates with Kotlin collections

Essentially Kotlin and Java collections are the same. `Map`, `List`, and `Set` are the same.

But Java does not distinguish between mutable and immutable collections. There's no compile-time check in Java to see if a collection is immutable (you can make a runtime check, though).


## 13.4 Using arrays in Kotlin

You can use `arrayOf`, `arrayOfNulls`, or the `Array()` constructor to create arrays of references (objects).

Each primitive type has its own array type: `IntArray`, `ByteArray`, `CharArray`, etc.

The presenter suggests that arrays are not collections but Kotlin offers the same methods for both.

```kotlin
fun main(args: Array<String>) {
    // note "indices"!
    for (i in args.indices) {
      // do stuff
    }
}
```

And assigning to an array index is the same as JS:

```kotlin
val items = IntArray(2)
items[0] = 1
items[1] = 2

// or we could have just done:
val numbers = intArrayOf(1, 2, 3, 4, 5)

// [JGQ: Why not just use arrayOf?]
```

`forEach` exists; also, check out the `forEachIndexed` method:

```kotlin
numbers.forEachIndexed{ index, element ->
  println("$index is: $element")
}
```

# 14. Using Higher Order Functions 

## 14.1 - Using Higher Order Functions - Intro

(nothing new)

## 14.2 - Declaring and Using Higher Order Functions

```kotlin
val calc = {x: Int, y: Int -> x * y}
// or
val calc : (Int, Int) -> Int = {x, y -> x * y}

```

## 14.3 - Inlining functions

- Lambdas map to anonymous classes in the bytecode
- Extra class and method created each time, this can be expensive*

If you use the `inline` keyword in a function, then in the bytecode the innards of the function will be simply spread into the calling function.

*Use when your function takes another function as an argument. Otherwise you'll get this: "Expected performance impact from inlining is insignificant. Inlining works best for functions with parameters of functional types"

i.e.
```kotlin
inline fun doSomething(func) {
  func()
}

fun main(args: Array<String>) {
  doSomething()
}
```
```java
/// in the bytecode, vastly simplified:
public static final void main(String[] args) {
  func()
}
```

"In order to reduce the memory overhead of such higher order functions or lambda expression we can use the `inline` keyword which ultimately requests the compiler to not allocate memory and simply copy the inlined code of that function at the calling place."

If we want to store a lambda in a variable, then we can't inline it. Because then the variable wouldn't have anything to reference. And syntactically, there's nowhere to put the word `inline`.

Internally, Kotlin inlines all of its collection operations, such as `map`, `filter`, etc. But on a `Sequence`, those operations are not inlined, since those functions are not immediately executed.

# 15. Generics

## 15.1 Generics - Introduction

This is valid:

```kotlin
// of what? Doesn't matter! It can be empty because once we're ready to `add` to this list, we know what type it's going to be.
val meetings:List<Meeting> = mutableListOf()
```

If you want your class to take a generic type, meaning a variable type, you could use the angle bracket syntax `<T>`. `T` can be anything, but seems like a convention to use `T` as a variable name for a generic type.

First, a class example. This is a `Node` class that can hold any type of `data`, but once that type is established, then all of its children must be of the same type. For instance:

```kotlin
data class Node<T> (val data: T) {
    var children = mutableListOf<Node<T>>()

    fun addChild(data: T): Node<T> {
        children.add(Node(data))
        return this
    }
}
```

Next, a function example. Functions behave differently in that the type parameters must *precede* the name of the function:

```kotlin
fun <T> lengthOf (iterable: T) : Int {
    if (iterable is List<*>) {
        return iterable.size
    }
    if (iterable is String) {
        return iterable.length
    }
    return -1
}
```

## 15.3 Constraints on Generics

Just because you create your function or class to accept a generic type doesn't mean it has to accept any type. You can constrain the types allowed, essentially making your type argument your own enum (rather than the enum being the entire list of types recognized by the compiler).

Let's take a look at this example again. Let's say you wanted this Node to accept any type of number, be it an int or a float. Luckily we have the `Number` "superclass for all platform classes representing numeric values".

So let's limit this generic type to be a number:

```kotlin
data class Node<T : Number> (val data: T) {
    var children = mutableListOf<Node<T>>()

    fun addChild(data: T): Node<T> {
        children.add(Node(data))
        return this
    }
}
```
Unfortunately, it doesn't look like you provide a list, i.e. `<T: Number, List<*>>`. The reason being, that comma is reserved for constraints corresponding to a second parameter. So this would certainly be possible: `<T, S: Number, List<*>>`, but means something different. `T` must be a `Number` of some kind, and `S` can be a list of anything.

## 15.4 Reifying Generic type information

There are issues with generics. Java erases all generic type information at runtime.

> Sadly, Kotlin has inherited Java's limitation on generics: they are strictly a compile-time concept - the generic type information is erased at runtime. Therefore, you can not say T() to construct a new instance of a generic type; you can not at runtime check if an object is an instance of a generic type parameter; and if you try to cast between generic types, the compiler can't guarantee the correctness of it.

Example:
```kotlin
fun printType(items: List<Any>) {
  // ERROR: Cannot check for instance of erased type: List<string>
  if (items is List<String>) {
    println("We have strings")
  }
}
```

Enter "reification" - to "reify" means to make something real. We want to reify the generic type into something the compiler can use.

Kotlin offers the ability to reify generic types on inline functions only.

Here's how you'd start off that declaration:
```kotlin
inline fun <reified T> fun sayHi(var arg: T)
```

## 15.5 Using Reified Generics

Here's an example. We want to use the construction `item is T` - "is this object `item` of variable type `T`" - which we can't do without reification.

```kotlin
// This new method will be added to any type of list: `List<*>`. Remember `List<Any>` and `List<Any?>` are different. This case covers them both.
inline fun <reified T> List<*>.getElementsByType(): List<T> {
    val elementsOfType = mutableListOf<T>()

    for (item in this) {
        if (item is T) {
            elementsOfType.add(item)
        }
    }
    return elementsOfType
}

fun main(args: Array<String>) {
    var list = listOf("hi", 3, null, "hello")
    var stringsInList = list.getElementsByType<String>()
    println(stringsInList.toString()) // output: [hi, hello]
}
```

## 15.6 Modifying Reification with 'noinline'

You can use `::class` to get metadata properties on a class.

If you make a function `inline`, then if it takes a function as an argument, that by default is `inline`; but you can mark it as `noinline`.

You can pass an entire class definition into a function if you want:

```kotlin
// Assuming `Meeting` is a supertype from which more specific types of meeting classes inherit.
fun <T: Meeting> buildMeeting(meetingClass: Class<T>) {
  val meeting : T = meetingClass.newInstance()
}

// Or instead of passing the class as an argument, just get to it via the metadata:
fun <T: Meeting> buildMeeting(meetingClass: Class<T>) {
  val meeting : T = T::class.java.newInstance()
}
```

## 15.7 Generic Variance in Kotlin

This is not safe:

```kotlin
// Assuming FinanceMeeting derives from Meeting
var meetings: MutableList<FinanceMeeting> = mutableListOf()

// Not allowed: FinanceMeeting may have more specific properties/methods than a generic Meeting, and this list is for FinanceMeetings only.
meetings.add(Meeting())
```
An interesting acronym from the Java world: PECS.

> For Producers, we use the Extends keyword.
> For Consumers, we use the Super keyword.

> "PECS" is from the collection's point of view. If you are only pulling items from a generic collection, it is a producer and you should use extends; if you are only stuffing items in, it is a consumer and you should use super. If you do both with the same collection, you shouldn't use either extends or super.

> A producer is allowed to produce something more specific, hence extends; a consumer is allowed to accept something more general, hence super.

> Invariance/non-variance: `MyClass`
> Covariance: `? extends MyClass`,
> Contravariance: `? super MyClass` and

Invariant: We can't pass a subtype to something that's expecting a type.
Covariant (`out`): A derived type can be used if the base type is more specific
Contravariant (`in`): A base type can be used if the derived type is more specific

Example
```kotlin
class MeetingGroup<out T: Meeting> (val meetings: List<Meeting>)
```

Still confused? Check this answer with my modifications to the end example:
https://stackoverflow.com/questions/55677861/what-does-in-out-actually-do-in-kotlin-when-passed-as-arguments/55680445#55680445

> Let me demonstrate what `in`/`out` do with the help of an example. Consider the following:
>
> ```kotlin
> private fun foo(list: ArrayList<Number>) {}
> private fun bar(list: ArrayList<Number>) {}
> ```
>
> Now we try to pass an `ArrayList` to each function, each with a different generic type parameter:
>
> ```kotlin
> // Error: Type Mismatch. Required `ArrayList<Number>` Found `ArrayList<Int>`
> foo(arrayListOf<Int>())
>
> // Error: Type Mismatch. Required `ArrayList<Number>` Found `ArrayList<Any>`
> bar(arrayListOf<Any>())
> ```
>
> But we get errors! How do we solve that? We have to tell the compiler somehow that, for foo the list can also contain elements of a subtype of Number (e.g. Int) and for bar we have to tell the compiler that the list can also contain elements of a basetype of Number (e.g. Any).
>
>```kotlin
>// WITH JG EDITS
>// The Number is a "producer" of other types. We can use types that come OUT of number
>private fun allowNumberAndSubtypes(list: ArrayList<out Number>) {
>  // `Int`, `Float`, `Double`, etc.
>}
>
>// The Number is a "consumer" of a higher type. Number is IN a larger type
>private fun allowAnyInWhichNumberIsASubtype(list: ArrayList<in Number>) {
>  // `Any`
>}
>```

And now it works!


## Extra Notes:

Re lists vs. arrays, from the documentation: "As you see, in some aspects lists are very similar to arrays. However, there is one important difference: an array's size is defined upon initialization and is never changed; in turn, a list doesn't have a predefined size; a list's size can be changed as a result of write operations: adding, updating, or removing elements.

In Kotlin, the default implementation of List is ArrayList which you can think of as a resizable array."
https://kotlinlang.org/docs/reference/collections-overview.html


Re: truthy and false, from the docs: "There are no automatic conversions to boolean and thus no concept of truthy and falsy: checks for zero, empty, or null must be done explicitly with == or !=. Most collection types have an isEmpty() and an isNotEmpty() function."
https://kotlinlang.org/docs/tutorials/kotlin-for-py/conditionals.html

